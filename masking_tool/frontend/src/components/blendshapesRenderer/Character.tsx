/**
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 public/Doggo07.glb -t
*/
import * as THREE from 'three'
import React, { useEffect, useRef, useState } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { AnimationAction } from 'three';
import Api from '../../api';
//import initalblendshapes from "./blendshapes.json"
const initalblendshapes = null

interface Blendshapes {
  [name: string]: number;
}

type GLTFResult = GLTF & {
  nodes: {
    Mesh: THREE.Mesh
    Mesh_1: THREE.Mesh
    Mesh_2: THREE.Mesh
    Mesh_3: THREE.Mesh
    Mesh_4: THREE.Mesh
    Mesh_5: THREE.Mesh
  }
  materials: {
    HAIR_SHD: THREE.MeshStandardMaterial
    GLASSES_SHD: THREE.MeshStandardMaterial
    DR_SHD: THREE.MeshStandardMaterial
    body_SHD: THREE.MeshStandardMaterial
    eye_SHD: THREE.MeshStandardMaterial
    eyelash_SHD: THREE.MeshStandardMaterial
  }
}
type ActionName = 'Expression' | 'KeyAction' | 'HeadMovement' | 'BodyAction'
type GLTFActions = Record<ActionName, THREE.AnimationAction>
function updateBlendshapes(node: THREE.Mesh, blendshapes: any) {
  if (!node.morphTargetDictionary) {
    return;
  }
  if (!node.morphTargetInfluences) {
    return;
  }
  let found = 0
  for (const name in blendshapes) {
    const value = blendshapes[name];
    if (!Object.keys(node.morphTargetDictionary).includes(name)) {
      continue;
    }
    found = found + 1
    const idx = node.morphTargetDictionary[name];
    node.morphTargetInfluences[idx] = value;
  }
  console.log(found)
} 

export function Character(props: JSX.IntrinsicElements['group']) {
  const { nodes, materials } = useGLTF('/character.glb') as GLTFResult
  const [blendshapes, setBlendshapes] = useState<any>(initalblendshapes)
  const [frameIndex, setFrameIndex] = useState(0)
  let count = 0

  useEffect(()=>{
    setInterval(() => {
      console.log(count)
      updateBlendshapes(nodes.Mesh_3, blendshapes[count]);
      count = count + 1
    }, 50);
  }, [nodes]);

  return (
    <group {...props} dispose={null}>
      <group rotation={[1.51, 0, 0]} scale={0.28}>
        <mesh name="Mesh" geometry={nodes.Mesh.geometry} material={materials["HAIR_SHD"]} morphTargetDictionary={nodes.Mesh.morphTargetDictionary} morphTargetInfluences={nodes.Mesh.morphTargetInfluences} />
        <mesh name="Mesh_1" geometry={nodes.Mesh_1.geometry} material={materials["GLASSES_SHD"]} morphTargetDictionary={nodes.Mesh_1.morphTargetDictionary} morphTargetInfluences={nodes.Mesh_1.morphTargetInfluences} />
        <mesh name="Mesh_2" geometry={nodes.Mesh_2.geometry} material={materials["DR_SHD"]} morphTargetDictionary={nodes.Mesh_2.morphTargetDictionary} morphTargetInfluences={nodes.Mesh_2.morphTargetInfluences} />
        <mesh name="Mesh_3" geometry={nodes.Mesh_3.geometry} material={materials["body_SHD"]} morphTargetDictionary={nodes.Mesh_3.morphTargetDictionary} morphTargetInfluences={nodes.Mesh_3.morphTargetInfluences} />
        <mesh name="Mesh_4" geometry={nodes.Mesh_4.geometry} material={materials["eye_SHD"]} morphTargetDictionary={nodes.Mesh_4.morphTargetDictionary} morphTargetInfluences={nodes.Mesh_4.morphTargetInfluences} />
        <mesh name="Mesh_5" geometry={nodes.Mesh_5.geometry} material={materials["eyelash_SHD"]} morphTargetDictionary={nodes.Mesh_5.morphTargetDictionary} morphTargetInfluences={nodes.Mesh_5.morphTargetInfluences} />
      </group>
    </group>
  )
}
useGLTF.preload('/character.glb')